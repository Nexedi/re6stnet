To be done :
    Add options to start udp server, tcp server or both

    use the server as a bootstrap node

    Use an algorithm to choose which connections to keep and/or establish
    instead of pure randomness

    Find a name for the project : the projet is ( or should be ) independant
    from vifib, openvpn, babel, and so should the name; btw we aim to build a
    distributed, scalable, resilient VPN.... ( if it helps with the name )

    Replace comments at the beginning of functions with docstrings & give all
    fn docstrings

    Use the server events ( client connection/deconnection ) to do something
    useful

    In peers DB, flag the dead peers so we only choose them if necessary and we can remove them if we have enought peers

    Use a timeout for the server peersDB so we can rflag unreachable peers and
    remove the peers whose certificate is no longer valid

    Specify a lease duration in ForwardViaUPnP

    Handle LAN internally in order not to have catastrophic results ....

To be discussed:
    G : Database structure for bith vifibnet and registry have been changed.
        Index is now always on the prefix ( there is no id anymore ). And
        the (ip, port, proto) tuples have been replaced with addresses :
        it is a list of ip, port, proto, that way a peer can announce
        different (port, proto) combination.

    G, J : To get traffic stats ( bytes in/out ), you can use
          /sys/class/net/interface/statistics/rx_bytes, etc...
        or /proc/net/dev/snmp6/interface ( all in one file ). This can be enough
        if used as follows: get traffic diff from last time we checked in order
        to choose which connection is significantly unused compared to others,
        and close it. Of course, too recent connections (i.e. those for which we
        have no previous stat) would be always kept.
        This should be combined with routing table (i.e. how many nodes are
        served by each tunnel), which is possibly redundant.
        ip6tables should be avoided if possible.
    U : Great !!!

    U : Babel seems to be very long to establish the routes : maybe we should
        tell him thant we are not on a wired network but on a mobile network ?
    G : babel establish routes quickly enough i'd say. There are two new
        options : hello and wireless, for hello_interval and treating all
        interfaces as wireless. However, treating an interface as wireless
        doesn't lessen the hello_interval, it only changes how babel estimates
        quality link, and cost.
    U : from babel web page : "When the Babel daemon detects a wired network,
        it will use a larger interval between hellos".
        Moreover, it seems that the wireless option only means
        "hostile environment" which seems best for a resilient network.
        30 sec of hello interval seams also too much. The default value for
        babel is 4 sec (from babel man page).
        According to raphael's stats on the nexedi's server downtime,
        45% of the problems dont last more than 2 minutes, 55% no more than
        3 minutes If it takes 2 min to detect a dead connection, then we wont be
        solving many problems with our overlay network

    U : The peer DB size should depend on the number of connection and the
        refresh time
    G : ?! I don't agree, the db size should be proportional ( with a factor
        like 0.01 or less ) to the total number of peers in the entire network,
        with maybe a max size.
    U : what we need to do  is to keep the randomness. For this, we need a big
        enought DB to ensure we can still choose a peer as if it was choosen
        directly from the server. The requiered db size can be calculated from
        the number of connections and the refresh time.

    U : Why are --ip and internal-port mutually exclusive ?
        Currently upnp only forward via UDP. Should he also forward via TCP ?
        Why dont we only use UDP ?
        No error should be raised when no upnp is detected : we should allow
        machines having public IP to do an automatic configuration using the
        discovery by an other peer
