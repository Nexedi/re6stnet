#!/usr/bin/python
import atexit, errno, logging, os, select, signal
import sqlite3, subprocess, sys, time, traceback
from re6st import plib, utils, db, tunnel


def getConfig():
    parser = utils.ArgParser(fromfile_prefix_chars='@',
        description="Resilient virtual private network application.")
    _ = parser.add_argument

    _('--ip',
        help="IP address advertised to other nodes. Special values:\n"
             "- upnp: redirect ports when UPnP device is found\n"
             "- any: ask peers our IP\n"
             " (default: like 'upnp' if miniupnpc is installed,\n"
             "  otherwise like 'any')")
    _('--registry', metavar='URL',
        help="Public HTTP URL of the registry, for bootstrapping.")
    _('-l', '--log', default='/var/log/re6stnet',
        help="Path to the directory used for log files:\n"
             "- re6stnet.log: log file of re6stnet itself\n"
             "- babeld.log: log file of router\n"
             "- <iface>.log: 1 file per spawned OpenVPN\n")
    _('-s', '--state', default='/var/lib/re6stnet',
        help="Path to re6stnet state directory:\n"
             "- peers.db: cache of peer addresses\n"
             "- babeld.state: see option -S of babeld\n")
    _('-v', '--verbose', default=1, type=int, metavar='LEVEL',
        help="Log level of re6stnet itself. 0 disables logging."
             " Use SIGUSR1 to reopen log."
             " See also --babel-verb and --verb for logs of spawned processes.")
    _('-i', '--interface', action='append', dest='iface_list', default=[],
        help="Extra interface for LAN discovery. Highly recommanded if there"
             " are other re6st node on the same network segment.")
    _('-I', '--main-interface', metavar='IFACE', default='lo',
        help="Set re6stnet IP on given interface. Any interface not used for"
             " tunnelling can be chosen.")
    _('--up', metavar='CMD',
        help="Shell command to run after successful initialization.")
    _('--daemon', action='append', metavar='CMD',
        help="Same as --up, but run in background: the command will be killed"
             " at exit (with a TERM signal, followed by KILL 5 seconds later"
             " if process is still alive).")

    _ = parser.add_argument_group('routing').add_argument
    _('-B', dest='babel_args', metavar='ARG', action='append', default=[],
        help="Extra arguments to forward to Babel.")
    _('--babel-pidfile', metavar='PID', default='/var/run/re6st-babeld.pid',
        help="Specify a file to write our process id to"
             " (option -I of Babel).")
    _('--hello', type=int, default=15,
        help="Hello interval in seconds, for both wired and wireless"
             " connections. OpenVPN ping-exit option is set to 4 times the"
             " hello interval. It takes between 3 and 4 times the"
             " hello interval for Babel to re-establish connection with a"
             " node for which the direct connection has been cut.")
    _('--table', type=int, default=42,
        help="Use given table id. Set 0 to use the main table, if:\n"
             "- you are a gateway of this network (the default route will be"
             "  exported)\n"
             "- or you want to use the default route of this network for all"
             " communications (in this case, make sure you don't already have"
             " a default route).\n")
    _ = parser.add_argument_group('tunnelling').add_argument
    _('-O', dest='openvpn_args', metavar='ARG', action='append', default=[],
        help="Extra arguments to forward to both server and client OpenVPN"
             " subprocesses. Often used to configure verbosity.")
    _('--ovpnlog', action='store_true',
        help="Tell each OpenVPN subprocess to log to a dedicated file.")
    _('--encrypt', action='store_true',
        help='Specify that tunnels should be encrypted.')
    _('--pp', nargs=2, action='append', metavar=('PORT', 'PROTO'),
        help="Port and protocol to be announced to other peers, ordered by"
             " preference. For each protocol (either udp or tcp), start one"
             " openvpn server on the first given port."
             " (default: --pp 1194 udp --pp 1194 tcp)")
    _('--dh',
        help='File containing Diffie-Hellman parameters in .pem format')
    _('--ca', required=True, help=parser._ca_help)
    _('--cert', required=True,
        help="Local peer's signed certificate in .pem format."
             " Common name defines the allocated prefix in the network.")
    _('--key', required=True,
        help="Local peer's private key in .pem format.")
    _('--client-count', default=10, type=int,
        help="Number of client tunnels to set up.")
    _('--max-clients', type=int,
        help="Maximum number of accepted clients per OpenVPN server. (default:"
             " client-count * 2, which actually represents the average number"
             " of tunnels to other peers)")
    _('--tunnel-refresh', default=300, type=int,
        help="Interval in seconds between two tunnel refresh: the worst"
             " tunnel is closed if the number of client tunnels has reached"
             " its maximum number (client-count).")
    _('--client', metavar='HOST,PORT,PROTO[;...]',
        help="Do not run any OpenVPN server, but only 1 OpenVPN client,"
             " with specified remotes. Any other option not required in this"
             " mode is ignored (e.g. client-count, max-clients, etc.)")

    return parser.parse_args()


def main():
    # Get arguments
    config = getConfig()
    network = utils.networkFromCa(config.ca)
    prefix = utils.binFromSubnet(utils.subnetFromCert(config.cert))
    config.openvpn_args += (
        '--ca', config.ca,
        '--cert', config.cert,
        '--key', config.key)
    # TODO: verify certificates (should we moved to M2Crypto ?)

    # Set logging
    utils.setupLog(config.verbose, os.path.join(config.log, 're6stnet.log'))

    logging.trace("Environment: %r", os.environ)
    logging.trace("Configuration: %r", config)
    utils.makedirs(config.state)
    db_path = os.path.join(config.state, 'peers.db')
    if config.ovpnlog:
        plib.ovpn_log = config.log

    signal.signal(signal.SIGHUP, lambda *args: sys.exit(-1))
    signal.signal(signal.SIGTERM, lambda *args: sys.exit())

    if config.max_clients is None:
        config.max_clients = config.client_count * 2

    address = []
    server_tunnels = {}
    if config.client:
        config.babel_args.append('re6stnet')
    elif config.max_clients:
        if config.pp:
            pp = [(int(port), proto) for port, proto in config.pp]
        else:
            pp = (1194, 'udp'), (1194, 'tcp')
        ip_changed = lambda ip: [(ip, str(port), proto) for port, proto in pp]
        forwarder = None
        if config.ip == 'upnp' or not config.ip:
            logging.info('Attempting automatic configuration via UPnP...')
            try:
                from re6st.upnpigd import Forwarder
                forwarder = Forwarder('re6stnet openvpn server')
            except Exception, e:
                if config.ip:
                    raise
                logging.info("%s: assume we are not NATed", e)
            else:
                atexit.register(forwarder.clear)
                for port, proto in pp:
                    forwarder.addRule(port, proto)
                ip_changed = forwarder.checkExternalIp
                address = ip_changed()
        elif config.ip != 'any':
            address = ip_changed(config.ip)
            ip_changed = None
        for x in pp:
            server_tunnels.setdefault('re6stnet-' + x[1], x)

    def call(cmd):
        logging.debug('%r', cmd)
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE)
        stdout, stderr = p.communicate()
        if p.returncode:
            raise EnvironmentError("%r failed with error %u\n%s"
                                   % (' '.join(cmd), p.returncode, stderr))
        return stdout
    def required(arg):
        if not getattr(config, arg):
            sys.exit("error: argument --%s is required" % arg)
    def ip(object, *args):
        args = ['ip', '-6', object, 'add'] + list(args)
        call(args)
        args[3] = 'del'
        cleanup.append(lambda: subprocess.call(args))

    try:
        subnet = network + prefix
        my_ip = '%s/%s' % (utils.ipFromBin(subnet, '1'), len(subnet))
        my_subnet = '%s/%u' % (utils.ipFromBin(subnet), len(subnet))
        my_network = "%s/%u" % (utils.ipFromBin(network), len(network))
        os.environ['re6stnet_ip'] = my_ip
        os.environ['re6stnet_iface'] = config.main_interface
        os.environ['re6stnet_subnet'] = my_subnet
        os.environ['re6stnet_network'] = my_network

        # Init db and tunnels
        tunnel_interfaces = server_tunnels.keys()
        timeout = 4 * config.hello
        if config.client_count and not config.client:
            required('registry')
            # Create and open read_only pipe to get server events
            r_pipe, write_pipe = os.pipe()
            read_pipe = os.fdopen(r_pipe)
            peer_db = db.PeerDB(db_path, config.registry, config.key, prefix)
            tunnel_manager = tunnel.TunnelManager(write_pipe, peer_db,
                config.openvpn_args, timeout, config.tunnel_refresh,
                config.client_count, config.iface_list, network, prefix,
                address, ip_changed, config.encrypt)
            tunnel_interfaces += tunnel_manager.new_iface_list
        else:
            tunnel_manager = write_pipe = None

        cleanup = []
        try:
            # Source address selection is defined by RFC 6724, and in most
            # applications, it usually works  thanks to rule 5 (prefer outgoing
            # interface). But here, it rarely applies because we use several
            # interfaces to connect to a re6st network.
            # Rule 7 is little strange because it prefers temporary addresses
            # over IP with a longer matching prefix (rule 8, which is not even
            # mandatory).
            # So only rule 6 can make the difference, i.e. prefer same label.
            # The value of the label does not matter, except that it must be
            # different from ::/0's (normally equal to 1).
            # XXX: This does not work with extra interfaces that already have
            #      an public IP so Babel must be changed to set a source
            #      address on routes it installs.
            ip('addrlabel', 'prefix', my_network, 'label', '99')
            # prepare persistent interfaces
            if config.client:
                cleanup.append(plib.client('re6stnet', config.client,
                    config.encrypt, '--ping-restart', str(timeout),
                    *config.openvpn_args).stop)
            elif server_tunnels:
                required('dh')
                for iface, (port, proto) in server_tunnels.iteritems():
                    cleanup.append(plib.server(iface, config.max_clients,
                        config.dh, write_pipe, port, proto, config.encrypt,
                        '--ping-exit', str(timeout), *config.openvpn_args).stop)

            ip('addr', my_ip, 'dev', config.main_interface)
            if_rt = ['ip', '-6', 'route', 'del',
                     'fe80::/64', 'dev', config.main_interface]
            if config.main_interface == 'lo':
                # WKRD: Removed this useless route now, since the kernel does
                #       not even remove it on exit.
                subprocess.call(if_rt)
            if_rt[4] = my_subnet
            cleanup.append(lambda: subprocess.call(if_rt))
            x = [my_network]
            if config.table:
                x += 'table', str(config.table)
                try:
                    ip('rule', 'from', *x)
                except EnvironmentError:
                    logging.error("It seems that your kernel was compiled"
                        " without support for source address based routing"
                        " (CONFIG_IPV6_SUBTREES). Consider using --table=0"
                        " option if you can't change your kernel.")
                    raise
                ip('rule', 'to', *x)
                call(if_rt)
                if_rt += x[1:]
                call(if_rt[:3] + ['add', 'proto', 'static'] + if_rt[4:])
            ip('route', 'unreachable', *x)

            config.babel_args += config.iface_list
            cleanup.append(plib.router(subnet, config.hello, config.table,
                os.path.join(config.log, 'babeld.log'),
                os.path.join(config.state, 'babeld.state'),
                config.babel_pidfile, tunnel_interfaces,
                *config.babel_args).stop)
            if config.up:
                r = os.system(config.up)
                if r:
                    sys.exit(r)
            for cmd in config.daemon or ():
                cleanup.append(utils.Popen(cmd, shell=True).stop)

            # main loop
            if tunnel_manager is None:
                sys.exit(os.WEXITSTATUS(os.wait()[1]))
            cleanup += tunnel_manager.delInterfaces, tunnel_manager.killAll
            while True:
                next = tunnel_manager.next_refresh
                if forwarder:
                    next = min(next, forwarder.next_refresh)
                r = [read_pipe, tunnel_manager.sock]
                try:
                    r = select.select(r, [], [], max(0, next - time.time()))[0]
                except select.error as e:
                    if e.args[0] != errno.EINTR:
                        raise
                    continue
                if read_pipe in r:
                    tunnel_manager.handleTunnelEvent(read_pipe.readline())
                if tunnel_manager.sock in r:
                    tunnel_manager.handlePeerEvent()
                t = time.time()
                if t >= tunnel_manager.next_refresh:
                    tunnel_manager.refresh()
                if forwarder and t >= forwarder.next_refresh:
                    forwarder.refresh()
        finally:
            while cleanup:
                try:
                    cleanup.pop()()
                except:
                    pass
    except sqlite3.Error:
        logging.exception("Restarting with empty cache")
        os.rename(db_path, db_path + '.bak')
        try:
            sys.exitfunc()
        finally:
            os.execvp(sys.argv[0], sys.argv)
    except KeyboardInterrupt:
        return 0
    except Exception:
        f = traceback.format_exception(*sys.exc_info())
        logging.error('%s%s', f.pop(), ''.join(f))
        sys.exit(1)

if __name__ == "__main__":
    main()
