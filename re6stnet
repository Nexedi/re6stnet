#!/usr/bin/env python
import argparse, atexit, errno, logging, os
import select, signal, sqlite3, sys, time, traceback
from re6st import plib, utils, db, tunnel

def ovpnArgs(optional_args, ca_path, cert_path, key_path):
    # Treat openvpn arguments
    if optional_args and optional_args[0] == "--":
        del optional_args[0]
    optional_args.append('--ca')
    optional_args.append(ca_path)
    optional_args.append('--cert')
    optional_args.append(cert_path)
    optional_args.append('--key')
    optional_args.append(key_path)
    return optional_args


def getConfig():
    parser = utils.ArgParser(fromfile_prefix_chars='@',
            description='Resilient virtual private network application')
    _ = parser.add_argument

    # General Configuration options
    _('--ip',
            help='IP address advertised to other nodes')
    _('--registry', required=True,
            help="HTTP URL of the discovery peer server,"
                 " with public host (default port: 80)")
    _('-l', '--log', default='/var/log/re6stnet',
            help='Path to re6stnet logs directory')
    _('-s', '--state', default='/var/lib/re6stnet',
            help='Path to re6stnet state directory')
    _('-v', '--verbose', default=1, type=int,
            help='Log level of re6stnet itself')
    _('-i', '--interface', action='append', dest='iface_list', default=[],
            help='Extra interface for LAN discovery')

    # Routing algorithm options
    _('--babel-pidfile',
            help='Specify a file to write our process id to')
    _('--babel-verb', default=0,
            help='Babel verbosity')
    _('--hello', type=int, default=15,
            help='Hello interval for babel, in seconds')
    _('-w', '--wireless', action='store_true',
            help='''Set all interfaces to be treated as wireless interfaces
                    for the routing protocol''')

    # Tunnel options
    _('--encrypt', action='store_true',
            help='specify that tunnels should be encrypted')
    _('--pp', nargs=2, action='append',
            help='Port and protocol to be used by other peers to connect')
    _('--dh', required=True,
            help='Path to dh file')
    _('--ca', required=True,
            help='Path to the certificate authority file')
    _('--cert', required=True,
            help='Path to the certificate file')
    _('--key', required=True,
            help='Path to the private key file')
    _('--connection-count', default=20, type=int,
            help='Number of tunnels')
    _('--tunnel-refresh', default=300, type=int,
            help='time (seconds) to wait before changing the connections')

    # Openvpn options
    _('openvpn_args', nargs=argparse.REMAINDER,
            help="Common OpenVPN options")
    return parser.parse_args()


def main():
    # Get arguments
    config = getConfig()
    network = utils.networkFromCa(config.ca)
    prefix = utils.binFromSubnet(utils.subnetFromCert(config.cert))
    openvpn_args = ovpnArgs(config.openvpn_args, config.ca, config.cert,
                                                 config.key)
    # Set logging
    utils.setupLog(config.verbose, os.path.join(config.log, 're6stnet.log'))

    logging.trace("Configuration:\n%r", config)
    utils.makedirs(config.state)
    db_path = os.path.join(config.state, 'peers.db')
    plib.log = tunnel.log = config.log

    # Create and open read_only pipe to get server events
    logging.info('Creating pipe for server events...')
    r_pipe, write_pipe = os.pipe()
    read_pipe = os.fdopen(r_pipe)

    signal.signal(signal.SIGHUP, lambda *args: sys.exit(-1))
    signal.signal(signal.SIGTERM, lambda *args: sys.exit())

    address = []
    if config.pp:
        pp = [(int(port), proto) for port, proto in config.pp]
    else:
        pp = (1194, 'udp'), (1194, 'tcp')
    ip_changed = lambda ip: [(ip, str(port), proto) for port, proto in pp]
    forwarder = None
    if config.ip == 'upnp' or not config.ip:
        logging.info('Attempting automatic configuration via UPnP...')
        try:
            from re6st.upnpigd import Forwarder
            forwarder = Forwarder()
        except Exception, e:
            if config.ip:
                raise
            logging.info("%s: assume we are not NATed", e)
        else:
            atexit.register(forwarder.clear)
            for port, proto in pp:
                ip, port = forwarder.addRule(port, proto)
                address.append((ip, str(port), proto))
    elif config.ip != 'any':
        address = ip_changed(config.ip)
    if address:
        ip_changed = None

    try:
        # Init db and tunnels
        peer_db = db.PeerDB(db_path, config.registry, config.key, prefix)
        tunnel_manager = tunnel.TunnelManager(write_pipe, peer_db, openvpn_args,
            config.hello, config.tunnel_refresh, config.connection_count,
            config.iface_list, network, prefix, address, ip_changed,
            config.encrypt)

        server_tunnels = {}
        for x in pp:
            server_tunnels.setdefault('re6stnet-' + x[1], x)
        interface_list = list(tunnel_manager.free_interface_set) \
                       + config.iface_list + server_tunnels.keys()
        subnet = network + prefix
        router = plib.router(network, utils.ipFromBin(subnet), len(subnet),
            interface_list, config.wireless, config.hello, config.babel_verb,
            config.babel_pidfile, os.path.join(config.state, 'babeld.state'))

        # main loop
        try:
            server_process = []
            for iface, (port, proto) in server_tunnels.iteritems():
                server_process.append(plib.server(iface,
                    utils.ipFromBin(subnet, '1') if proto == pp[0][1] else None,
                    len(network) + len(prefix),
                    config.connection_count, config.dh, write_pipe, port,
                    proto, config.hello, config.encrypt, *openvpn_args))
            while True:
                next = tunnel_manager.next_refresh
                if forwarder:
                    next = min(next, forwarder.next_refresh)
                r = [read_pipe, tunnel_manager.sock]
                try:
                    r = select.select(r, [], [], max(0, next - time.time()))[0]
                except select.error as e:
                    if e.args[0] != errno.EINTR:
                        raise
                    continue
                if read_pipe in r:
                    tunnel_manager.handleTunnelEvent(read_pipe.readline())
                if tunnel_manager.sock in r:
                    tunnel_manager.handlePeerEvent()
                t = time.time()
                if t >= tunnel_manager.next_refresh:
                    tunnel_manager.refresh()
                if forwarder and t >= forwarder.next_refresh:
                    forwarder.refresh()
        finally:
            router.terminate()
            for p in server_process:
                try:
                    p.kill()
                except:
                    pass
            try:
                tunnel_manager.killAll()
            except:
                pass
    except sqlite3.Error:
        logging.exception("Restarting with empty cache")
        os.rename(db_path, db_path + '.bak')
        try:
            sys.exitfunc()
        finally:
            os.execvp(sys.argv[0], sys.argv)
    except KeyboardInterrupt:
        return 0
    except Exception:
        f = traceback.format_exception(*sys.exc_info())
        logging.error('%s%s', f.pop(), ''.join(f))
        sys.exit(1)

if __name__ == "__main__":
    main()
